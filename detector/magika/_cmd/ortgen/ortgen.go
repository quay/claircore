package main

import (
	"archive/tar"
	"bufio"
	"bytes"
	"compress/gzip"
	"context"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"modernc.org/cc/v4"
)

const tarURL = "https://github.com/microsoft/onnxruntime/releases/download/v1.15.1/onnxruntime-linux-x64-1.15.1.tgz"

func main() {
	var code int
	defer func() {
		if code != 0 {
			os.Exit(code)
		}
	}()
	var out *os.File
	in := flag.String("url", tarURL, "fetch ONNX Runtime release tarball from `URL`")
	pkg := flag.String("pacakge", "magika", "generated package `name`")
	flag.Func("o", "output to `file`", func(p string) error {
		if out != nil {
			if err := out.Close(); err != nil {
				return err
			}
		}
		f, err := os.Create(p)
		if err != nil {
			return err
		}
		out = f
		return nil
	})
	flag.Parse()

	if out == nil {
		out = os.Stdout
	}
	defer out.Close()

	ctx := context.Background()
	if err := Main(ctx, out, *in, *pkg); err != nil {
		fmt.Fprintln(os.Stderr, err)
		code = 1
	}
}

const genHeader = `// Code generated by ortgen. DO NOT EDIT.`

func Main(ctx context.Context, out io.Writer, in, pkg string) error {
	const header = `onnxruntime_c_api.h`
	dir, err := fetchTarball(ctx, in)
	if err != nil {
		return err
	}
	defer os.RemoveAll(dir.Name())
	defer dir.Close()

	cfg, err := cc.NewConfig("linux", "amd64")
	if err != nil {
		return err
	}
	ms, _ := fs.Glob(dir.FS(), `*/include/`+header)
	f, err := dir.Open(ms[0])
	if err != nil {
		return err
	}
	src := []cc.Source{
		{Name: "<predefined>", Value: cfg.Predefined},
		{Name: "<builtin>", Value: cc.Builtin},
		{Name: header, Value: f},
	}
	ast, err := cc.Translate(cfg, src)
	if err != nil {
		return err
	}

	fmt.Fprintf(out, "%s\n\npackage %s\n\nimport \"structs\"\n", genHeader, pkg)
	// Walk the list, looking for the bits we want:
	var buf bytes.Buffer
	for cur := ast.TranslationUnit; cur != nil; cur = cur.TranslationUnit {
		buf.Reset()
		if cur.ExternalDeclaration.Case != cc.ExternalDeclarationDecl {
			continue
		}
		decl := cur.ExternalDeclaration.Declaration
		if decl.Position().Filename != header {
			continue
		}
		spec := decl.DeclarationSpecifiers
		if spec == nil || spec.Case != cc.DeclarationSpecifiersTypeSpec {
			continue
		}
		ty := spec.TypeSpecifier
		if ty == nil || ty.Case != cc.TypeSpecifierStructOrUnion {
			continue
		}
		structSpec := ty.StructOrUnionSpecifier
		if structSpec == nil ||
			structSpec.Case != cc.StructOrUnionSpecifierDef ||
			structSpec.StructOrUnion.Case != cc.StructOrUnionStruct {
			continue
		}

		n := structSpec.Token.SrcStr()
		switch n {
		case "OrtApi":
		case "OrtApiBase":
		default:
			continue
		}
		fmt.Fprintf(&buf, "\ntype %s struct {\n\t_ structs.HostLayout\n\n", strings.Replace(n, "O", "o", 1))

		for cur := structSpec.StructDeclarationList; cur != nil; cur = cur.StructDeclarationList {
			buf.WriteString("\t// ")
			buf.WriteString(cc.NodeSource(cur.StructDeclaration))
			buf.WriteByte('\n')

			// pull out the function pointer ident:
			decl := cur.StructDeclaration.StructDeclaratorList.StructDeclarator.Declarator.DirectDeclarator.DirectDeclarator.Declarator.DirectDeclarator
			buf.WriteByte('\t')
			buf.Write(decl.Token.Src())
			buf.WriteString(" uintptr\n")
		}

		buf.WriteString("}\n")
		if _, err := io.Copy(out, &buf); err != nil {
			return err
		}
	}

	return nil
}

func fetchTarball(ctx context.Context, in string) (*os.Root, error) {
	res, err := http.Get(in)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status: %v", res.Status)
	}
	defer res.Body.Close()
	z, err := gzip.NewReader(res.Body)
	if err != nil {
		return nil, err
	}

	d, err := os.MkdirTemp("", "ortgen.")
	if err != nil {
		return nil, err
	}
	root, err := os.OpenRoot(d)
	if err != nil {
		return nil, err
	}

	ok := false
	defer func() {
		if !ok {
			os.RemoveAll(d)
			root.Close()
		}
	}()

	rd := tar.NewReader(bufio.NewReader(z))
	h, err := rd.Next()
	for ; err == nil; h, err = rd.Next() {
		err := func() error {
			p := filepath.Join(".", h.Name)
			fi := h.FileInfo()
			if fi.IsDir() {
				return root.Mkdir(p, 0o755)
			}
			f, err := root.Create(p)
			if err != nil {
				return err
			}
			defer f.Close()

			if _, err := io.Copy(f, rd); err != nil {
				return err
			}
			return nil
		}()
		if err != nil {
			return nil, err
		}
	}

	ok = true
	return root, nil
}
