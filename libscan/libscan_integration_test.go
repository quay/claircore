// +build integration-unix

package libscan

import (
	"context"
	"encoding/json"
	"fmt"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/quay/claircore"
	"github.com/quay/claircore/internal/scanner"
	"github.com/quay/claircore/internal/scanner/postgres"
	"github.com/quay/claircore/test"
	"github.com/stretchr/testify/assert"
)

const (
	conn = "host=localhost port=5434 user=libscan dbname=libscan password=libscan sslmode=disable"
)

// Test_Libscan_Scan tests that our library performs a successful scan.
// we mock out the package scanners to return sets of packages generated by
// test functions.
func Test_Libscan_Scan(t *testing.T) {
	var tt = []struct {
		// the name of the test
		name string
		// the number of layers to place in the manifest under test
		layers int
		// the uri to populate into reach layer's RemotePath.URI field.
		// len(uris) must equal the int in the layers field
		uris []string
		// the number of packages to generate for each layer
		// len(pkgs) must equal the int in the layers field
		pkgs []int
		// the number of mock scanners to create. must be
		// >= 1.
		scnrs int
		// the name of the manifest under test
		hash string
	}{
		{
			name:   "1 layer; 1 scnr; 1 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "1 layer; 2 scnr; 2 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 1 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 2 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 1 scnr; 1 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 2 scnr; 2 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 3 scnr; 3 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{3, 3, 3},
			scnrs: 3,
			hash:  "test-manifest",
		},
	}
	t.Run("integration", func(t *testing.T) {
		for _, table := range tt {
			t.Run(table.name, func(t *testing.T) {
				mscnrs := []*scanner.MockPackageScanner{}
				scnrs := []scanner.PackageScanner{}
				ctrl := gomock.NewController(t)

				// create the desired number of package scanners. we will
				// configure the Scan() method on the mock when generated layers below
				for i := 0; i < table.scnrs; i++ {
					mscnr := scanner.NewMockPackageScanner(ctrl)
					mscnr.EXPECT().Name().AnyTimes().Return(fmt.Sprintf("test-scanner-%d", i))
					mscnr.EXPECT().Version().AnyTimes().Return("v0.0.1")
					mscnr.EXPECT().Kind().AnyTimes().Return("package")
					mscnrs = append(mscnrs, mscnr)
				}

				// configure scanners to return the desired pkg counts
				for i := 0; i < table.layers; i++ {
					// generate the desired number of package we'll return for this layer
					pkgs := test.GenUniquePackages(table.pkgs[i])

					// configure the desired scanners to return this set of pkgs when their Scan()
					// are called.
					for _, mscnr := range mscnrs {
						mscnr.EXPECT().Scan(gomock.Any()).Return(pkgs, nil)
					}
				}
				// convert to scanner.PackageScanner array
				for _, mscnr := range mscnrs {
					scnrs = append(scnrs, scanner.PackageScanner(mscnr))
				}

				// generate layers
				layers, err := test.GenUniqueLayersRemote(table.layers, table.uris)
				if err != nil {
					t.Fatalf("failed to generate unique layers: %v", err)
				}

				// create manifest
				m := &claircore.Manifest{
					Hash:   table.hash,
					Layers: layers,
				}

				// create libscan instance
				opts := &Opts{
					DataStore:            Postgres,
					ConnString:           conn,
					ScanLock:             PostgresSL,
					ScanLockRetry:        2 * time.Second,
					LayerScanConcurrency: 1,
					LayerFetchOpt:        scanner.InMem,
				}

				// just grab teardown function to clear the db after test
				_, _, teardown := postgres.NewTestStore(t)
				defer teardown()

				lib, err := New(opts)
				if err != nil {
					t.Fatalf("failed to create libscan instance: %v", err)
				}

				//setup scan and run
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				c, err := lib.Scan(ctx, m)
				if err != nil {
					t.Fatalf("failed to scan manifest: %v", err)
				}

				var sr *scanner.ScanReport
				select {
				case <-ctx.Done():
					t.Fatalf("context timed out: %v", ctx.Err())
				case sr = <-c:
					out, err := json.MarshalIndent(sr, "", "    ")
					if err != nil {
						t.Fatalf("failed to marshal scan report: %v", err)
					}
					fmt.Println(string(out))
				}

				// confirm sr ha the manifest hash we expect
				assert.Equal(t, table.hash, sr.Hash)
				assert.True(t, sr.Success)

				// confirm scan report retrieved from libscan matches the one
				// the Scan() method returned
				sr1, ok, err := lib.ScanReport(table.hash)
				assert.NoError(t, err)
				assert.True(t, ok)
				assert.Equal(t, sr, sr1)

			})
		}

	})
}

// Test_Libscan_Scan_Parallel tests that our library performs a successful scan.
// we mock out the package scanners to return sets of packages generated by
// test functions.
func Test_Libscan_Scan_Parallel(t *testing.T) {
	var tt = []struct {
		// the name of the test
		name string
		// the number of layers to place in the manifest under test
		layers int
		// the uri to populate into reach layer's RemotePath.URI field.
		// len(uris) must equal the int in the layers field
		uris []string
		// the number of packages to generate for each layer
		// len(pkgs) must equal the int in the layers field
		pkgs []int
		// the number of mock scanners to create. must be
		// >= 1.
		scnrs int
		// the name of the manifest under test
		hash string
	}{
		{
			name:   "1 layer; 1 scnr; 1 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "1 layer; 2 scnr; 2 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 1 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 2 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 1 scnr; 1 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 2 scnr; 2 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 3 scnr; 3 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{3, 3, 3},
			scnrs: 3,
			hash:  "test-manifest",
		},
	}
	t.Run("integration", func(t *testing.T) {
		for _, tab := range tt {
			// just grab teardown function to clear the db after test
			_, _, teardown := postgres.NewTestStore(t)
			defer teardown()
			t.Run("blocking-group", func(t *testing.T) {

				table := tab
				t.Run(table.name, func(t *testing.T) {
					t.Parallel()

					mscnrs := []*scanner.MockPackageScanner{}
					scnrs := []scanner.PackageScanner{}
					ctrl := gomock.NewController(t)

					// create the desired number of package scanners. we will
					// configure the Scan() method on the mock when generated layers below
					for i := 0; i < table.scnrs; i++ {
						mscnr := scanner.NewMockPackageScanner(ctrl)
						mscnr.EXPECT().Name().AnyTimes().Return(fmt.Sprintf("test-scanner-%d", i))
						mscnr.EXPECT().Version().AnyTimes().Return("v0.0.1")
						mscnr.EXPECT().Kind().AnyTimes().Return("package")
						mscnrs = append(mscnrs, mscnr)
					}

					// configure scanners to return the desired pkg counts
					for i := 0; i < table.layers; i++ {
						// generate the desired number of package we'll return for this layer
						pkgs := test.GenUniquePackages(table.pkgs[i])

						// configure the desired scanners to return this set of pkgs when their Scan()
						// are called.
						for _, mscnr := range mscnrs {
							mscnr.EXPECT().Scan(gomock.Any()).Return(pkgs)
						}
					}
					// convert to scanner.PackageScanner array
					for _, mscnr := range mscnrs {
						scnrs = append(scnrs, scanner.PackageScanner(mscnr))
					}

					// generate layers
					layers, err := test.GenUniqueLayersRemote(table.layers, table.uris)
					if err != nil {
						t.Fatalf("failed to generate unique layers: %v", err)
					}

					// create manifest
					m := &claircore.Manifest{
						Hash:   table.hash,
						Layers: layers,
					}

					// create libscan instance
					opts := &Opts{
						DataStore:            Postgres,
						ConnString:           conn,
						ScanLock:             PostgresSL,
						ScanLockRetry:        2 * time.Second,
						LayerScanConcurrency: 1,
						LayerFetchOpt:        scanner.InMem,
					}

					lib, err := New(opts)
					if err != nil {
						t.Fatalf("failed to create libscan instance: %v", err)
					}

					//setup scan and run
					ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
					defer cancel()

					c, err := lib.Scan(ctx, m)
					if err != nil {
						t.Fatalf("failed to scan manifest: %v", err)
					}

					var sr *scanner.ScanReport
					select {
					case <-ctx.Done():
						t.Fatalf("context timed out: %v", ctx.Err())
					case sr = <-c:
						out, err := json.MarshalIndent(sr, "", "    ")
						if err != nil {
							t.Fatalf("failed to marshal scan report: %v", err)
						}
						fmt.Println(string(out))
					}

					// confirm sr ha the manifest hash we expect
					assert.Equal(t, table.hash, sr.Hash)
					assert.True(t, sr.Success)

					// confirm scan report retrieved from libscan matches the one
					// the Scan() method returned
					sr1, ok, err := lib.ScanReport(table.hash)
					assert.NoError(t, err)
					assert.True(t, ok)
					assert.Equal(t, sr, sr1)

				})

			})
		}

	})
}
