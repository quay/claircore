package libindex

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/assert"

	"github.com/quay/claircore"
	"github.com/quay/claircore/internal/indexer"
	"github.com/quay/claircore/internal/indexer/postgres"
	"github.com/quay/claircore/test"
	"github.com/quay/claircore/test/integration"
)

// Test_Libindex_Scan tests that our library performs a successful scan.
// we mock out the package scanners to return sets of packages generated by
// test functions.
func Test_Libindex_Scan(t *testing.T) {
	integration.Skip(t)
	var tt = []struct {
		// the name of the test
		name string
		// the number of layers to place in the manifest under test
		layers int
		// the uri to populate into reach layer's RemotePath.URI field.
		// len(uris) must equal the int in the layers field
		uris []string
		// the number of packages to generate for each layer
		// len(pkgs) must equal the int in the layers field
		pkgs []int
		// the number of mock scanners to create. must be
		// >= 1.
		scnrs int
		// the name of the manifest under test
		hash string
	}{
		{
			name:   "1 layer; 1 scnr; 1 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "1 layer; 2 scnr; 2 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 1 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 2 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 1 scnr; 1 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 2 scnr; 2 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 3 scnr; 3 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{3, 3, 3},
			scnrs: 3,
			hash:  "test-manifest",
		},
	}
	t.Run("integration", func(t *testing.T) {
		for _, table := range tt {
			t.Run(table.name, func(t *testing.T) {
				mscnrs := []*indexer.MockPackageScanner{}
				scnrs := []indexer.PackageScanner{}
				ctrl := gomock.NewController(t)

				// create the desired number of package scanners. we will
				// configure the Scan() method on the mock when generated layers below
				for i := 0; i < table.scnrs; i++ {
					mscnr := indexer.NewMockPackageScanner(ctrl)
					mscnr.EXPECT().Name().AnyTimes().Return(fmt.Sprintf("test-scanner-%d", i))
					mscnr.EXPECT().Version().AnyTimes().Return("v0.0.1")
					mscnr.EXPECT().Kind().AnyTimes().Return("package")
					mscnrs = append(mscnrs, mscnr)
				}

				// configure scanners to return the desired pkg counts
				for i := 0; i < table.layers; i++ {
					// generate the desired number of package we'll return for this layer
					pkgs := test.GenUniquePackages(table.pkgs[i])

					// configure the desired scanners to return this set of pkgs when their Scan()
					// are called.
					for _, mscnr := range mscnrs {
						mscnr.EXPECT().Scan(gomock.Any(), gomock.Any()).Return(pkgs, nil)
					}
				}
				// convert to scanner.PackageScanner array
				for _, mscnr := range mscnrs {
					scnrs = append(scnrs, indexer.PackageScanner(mscnr))
				}

				// generate layers
				layers, err := test.GenUniqueLayersRemote(table.layers, table.uris)
				if err != nil {
					t.Fatalf("failed to generate unique layers: %v", err)
				}

				// create manifest
				m := &claircore.Manifest{
					Hash:   table.hash,
					Layers: layers,
				}

				// just grab teardown function to clear the db after test
				ctx := context.Background()
				_, _, dsn, teardown := postgres.TestStore(ctx, t)
				defer teardown()

				// create libindex instance
				opts := &Opts{
					ConnString:           dsn,
					ScanLockRetry:        2 * time.Second,
					LayerScanConcurrency: 1,
				}

				lib, err := New(ctx, opts)
				if err != nil {
					t.Fatalf("failed to create libindex instance: %v", err)
				}

				//setup scan and run
				ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
				defer cancel()

				ir, err := lib.Index(ctx, m)
				if err != nil {
					t.Fatalf("failed to scan manifest: %v", err)
				}

				// confirm sr ha the manifest hash we expect
				assert.Equal(t, table.hash, ir.Hash)
				assert.True(t, ir.Success)

				// confirm scan report retrieved from libindex matches the one
				// the Scan() method returned
				sr1, ok, err := lib.IndexReport(ctx, table.hash)
				assert.NoError(t, err)
				assert.True(t, ok)
				assert.Equal(t, ir, sr1)

			})
		}

	})
}

// Test_Libindex_Scan_Parallel tests that our library performs a successful scan.
// we mock out the package scanners to return sets of packages generated by
// test functions.
func Test_Libindex_Scan_Parallel(t *testing.T) {
	integration.Skip(t)
	var tt = []struct {
		// the name of the test
		name string
		// the number of layers to place in the manifest under test
		layers int
		// the uri to populate into reach layer's RemotePath.URI field.
		// len(uris) must equal the int in the layers field
		uris []string
		// the number of packages to generate for each layer
		// len(pkgs) must equal the int in the layers field
		pkgs []int
		// the number of mock scanners to create. must be
		// >= 1.
		scnrs int
		// the name of the manifest under test
		hash string
	}{
		{
			name:   "1 layer; 1 scnr; 1 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "1 layer; 2 scnr; 2 packages found",
			layers: 1,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 1 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 1 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "2 layer; 2 scnr; 2 packages found",
			layers: 2,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 1 scnr; 1 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{1, 1, 1},
			scnrs: 1,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 2 scnr; 2 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{2, 2, 2},
			scnrs: 2,
			hash:  "test-manifest",
		},
		{
			name:   "3 layer; 3 scnr; 3 packages found",
			layers: 3,
			uris: []string{
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
				"https://storage.googleapis.com/quay-sandbox-01/datastorage/registry/sha256/bb/bb7a526fbe0a09a1f951cec60de07ed8d54ba1947280125b6ba4406987a05b2d",
			},
			pkgs:  []int{3, 3, 3},
			scnrs: 3,
			hash:  "test-manifest",
		},
	}
	t.Run("integration", func(t *testing.T) {
		for _, tab := range tt {
			ctx := context.Background()
			// just grab teardown function to clear the db after test
			_, _, dsn, teardown := postgres.TestStore(ctx, t)
			defer teardown()
			t.Run("blocking-group", func(t *testing.T) {

				table := tab
				t.Run(table.name, func(t *testing.T) {
					t.Parallel()

					mscnrs := []*indexer.MockPackageScanner{}
					scnrs := []indexer.PackageScanner{}
					ctrl := gomock.NewController(t)

					// create the desired number of package scanners. we will
					// configure the Scan() method on the mock when generated layers below
					for i := 0; i < table.scnrs; i++ {
						mscnr := indexer.NewMockPackageScanner(ctrl)
						mscnr.EXPECT().Name().AnyTimes().Return(fmt.Sprintf("test-scanner-%d", i))
						mscnr.EXPECT().Version().AnyTimes().Return("v0.0.1")
						mscnr.EXPECT().Kind().AnyTimes().Return("package")
						mscnrs = append(mscnrs, mscnr)
					}

					// configure scanners to return the desired pkg counts
					for i := 0; i < table.layers; i++ {
						// generate the desired number of package we'll return for this layer
						pkgs := test.GenUniquePackages(table.pkgs[i])

						// configure the desired scanners to return this set of pkgs when their Scan()
						// are called.
						for _, mscnr := range mscnrs {
							mscnr.EXPECT().Scan(gomock.Any(), gomock.Any()).Return(pkgs, nil)
						}
					}
					// convert to scanner.PackageScanner array
					for _, mscnr := range mscnrs {
						scnrs = append(scnrs, indexer.PackageScanner(mscnr))
					}

					// generate layers
					layers, err := test.GenUniqueLayersRemote(table.layers, table.uris)
					if err != nil {
						t.Fatalf("failed to generate unique layers: %v", err)
					}

					// create manifest
					m := &claircore.Manifest{
						Hash:   table.hash,
						Layers: layers,
					}

					// create libindex instance
					opts := &Opts{
						ConnString:           dsn,
						ScanLockRetry:        2 * time.Second,
						LayerScanConcurrency: 1,
					}

					lib, err := New(ctx, opts)
					if err != nil {
						t.Fatalf("failed to create libindex instance: %v", err)
					}

					//setup scan and run
					ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
					defer cancel()

					ir, err := lib.Index(ctx, m)
					if err != nil {
						t.Fatalf("failed to scan manifest: %v", err)
					}

					// confirm sr ha the manifest hash we expect
					assert.Equal(t, table.hash, ir.Hash)
					assert.True(t, ir.Success)

					// confirm scan report retrieved from libindex matches the one
					// the Scan() method returned
					sr1, ok, err := lib.IndexReport(ctx, table.hash)
					assert.NoError(t, err)
					assert.True(t, ok)
					assert.Equal(t, ir, sr1)

				})

			})
		}

	})
}
