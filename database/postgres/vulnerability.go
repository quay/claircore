package postgres

import (
	"crypto/md5"
	"io"

	"github.com/quay/claircore/updater/driver/v1"
)

// The database package has its own concept of a vulnerability that is several
// different logical objects mashed together into one very wide row.
//
// This was done to be able to avoid joins at query time, but may be more
// trouble than it's worth. Need to measure and plan a migration to separate
// tables if it doesn't murder performance.

/*
type vulnerability struct{
	updater  string
	name          string
	description     string
	issued                 timestamptz,
	links     string
	severity       string
	normalized_severity    TEXT,
	package_name           TEXT,
	package_version        TEXT,
	package_module         TEXT,
	package_arch           TEXT,
	package_kind           TEXT,
	dist_id                TEXT,
	dist_name              TEXT,
	dist_version           TEXT,
	dist_version_code_name TEXT,
	dist_version_id        TEXT,
	dist_arch              TEXT,
	dist_cpe               TEXT,
	dist_pretty_name       TEXT,
	repo_name              TEXT,
	repo_key               TEXT,
	repo_uri               TEXT,
	fixed_in_version       TEXT,
	arch_operation         TEXT,
	vulnerable_range       VersionRange NOT NULL DEFAULT VersionRange('{}', '{}', '()'),
	version_kind           TEXT,
	UNIQUE (hash_kind, hash)
}

func (v *vulnerability) hash() (string, []byte) {
	return "", nil
}
*/

// Vuln is the indexes for a single exploded vulnerability.
type vuln struct {
	Vulnerability int
	Package       int
	Distribution  int
	Repository    int
}

func (vi vuln) Hash(vs *driver.ParsedVulnerabilities) (string, []byte) {
	out := make([]byte, 0, md5.Size)
	h := md5.New()
	v := vs.Vulnerability[vi.Vulnerability]
	io.WriteString(h, v.Name)
	io.WriteString(h, v.Description)
	io.WriteString(h, v.Issued.String())
	// This mimics the old links format -- we need to swap out this algorithm.
	// Luckily, the kind can be updated.
	for i, l := range v.Links {
		if i != 0 {
			h.Write([]byte(" "))
		}
		io.WriteString(h, l)
	}
	io.WriteString(h, v.Severity.Upstream)

	if i := vi.Package; i != -1 {
		p := vs.Package[i]
		io.WriteString(h, p.Name)
		io.WriteString(h, p.Version)
		io.WriteString(h, p.Module)
		io.WriteString(h, p.Arch)
		io.WriteString(h, p.Kind.String())
	}
	if i := vi.Distribution; i != -1 {
		d := vs.Distribution[i]
		io.WriteString(h, d.ID)
		// io.WriteString(h, d.Name)
		// io.WriteString(h, d.Version)
		// io.WriteString(h, d.VersionCodeName)
		io.WriteString(h, d.VersionID)
		io.WriteString(h, d.Arch)
		io.WriteString(h, d.CPE.BindFS())
		// io.WriteString(h, d.PrettyName)
	}
	if i := vi.Repository; i != -1 {
		r := vs.Repository[i]
		io.WriteString(h, r.Name)
		io.WriteString(h, r.Key)
		io.WriteString(h, r.URI)
		io.WriteString(h, r.CPE.BindFS())
	}
	io.WriteString(h, v.ArchOperation.String())
	io.WriteString(h, v.FixedInVersion)
	if k, l, u := rangefmt(v.Range); k != "" {
		io.WriteString(h, k)
		io.WriteString(h, l)
		io.WriteString(h, u)
	}

	return `md5`, h.Sum(out)
}
