<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adding Distribution Or Language Support - Claircore Documentation</title>


        <!-- Custom HTML head -->
        <script>
        mermaid.initialize({
          startOnLoad: true,
        });
        </script>

        <meta name="description" content="Additional documentation for Claircore.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Claircore Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/quay/claircore" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="adding-distribution-and-language-support"><a class="header" href="#adding-distribution-and-language-support">Adding Distribution And Language Support</a></h1>
<p><em>Note: If terms in this document sound foreign check out <a href="../getting_started.html">Getting Started</a> to acquaint yourself with "indexing", "scanning", and "matching"</em></p>
<p>The claircore team is always open to adding more distributions and languages to the library.</p>
<p>Generally, distributions or languages must provide a security tracker.</p>
<p>All officially supported distributions and languages provide a database of security vulnerabilities.</p>
<p>These databases are maintained by the distribution or language developers and reflect up-to-date CVE and advisory data for their packages.</p>
<p>If your distribution or language does not provide a security tracker or piggy-backs off another distribution's start an issue in our Github issue tracker to discuss further.</p>
<h2 id="implementing-an-updater"><a class="header" href="#implementing-an-updater">Implementing an Updater</a></h2>
<p>The first step to adding your distribution or language to claircore is getting your security tracker's data ingested by Libvuln.</p>
<p>The Updater interfaces are responsible for this task.</p>
<p>An implementer must consider several design points:</p>
<ul>
<li>Does the security database provide enough information to parse each entry into a claircore.Vulnerability?
<ul>
<li>Each entry must parse into a claircore.Vulnerability.</li>
<li>Each Vulnerability <strong>must</strong> contain a package <strong>and</strong> a repository <strong>or</strong> distribution field.</li>
</ul>
</li>
<li>Will the Updater need to be configured at runtime?
<ul>
<li>Your updater may implement the Configurable interface. Your matcher will have its "Configuration" method called before use, giving you an opportunity for run time configuration.</li>
</ul>
</li>
<li>What fields in a parsed claircore.Vulnerability will be present when indexing layer artifacts.
<ul>
<li>When implementing an updater you must keep in mind how packages/distributions/repositories will be parsed during index.
When indexing a layer a common data model <strong>must</strong> exist between the possible package/distribution/repository and the parsed Vulnerabilitie's package/distribution/repository fields.</li>
</ul>
</li>
</ul>
<p>If you are having trouble figuring out these requirements do not hesitate to reach out to us for help.</p>
<p>After you have taken the design points into consideration, you are ready to implement your updater.</p>
<p>Typically you will create a new package named after the source you are adding support for.</p>
<p>Inside this package you can begin implementing the <a href="../reference/updater.html">Updater</a> and <a href="../reference/updatersetfactory.html">Updater Set Factory</a> interfaces.</p>
<p>Optionally you may implement the <a href="../reference/updater.html">Configurable</a> interface if you need runtime configuration.</p>
<p>It will undoubtly be helpful to look at the examples in the "ubuntu", "rhel", and "debian" packages to get yourself started.</p>
<h2 id="implementing-a-package-scanner"><a class="header" href="#implementing-a-package-scanner">Implementing a Package Scanner</a></h2>
<p>At this point you hopefully have your Updater working, writing vulnerability data into Libvuln's database.</p>
<p>We can now move our attention to package scanning.</p>
<p>A package scanner is responsible for taking a claircore.Layer and parsing the contents for a particular package database or set of files inside the provided tar archive.
Once the target files are located the package scanner should parse these files into claircore.Packages and return a slice of these data structures.</p>
<p>Package scanning is context free, meaning no distribution classification has happened yet.
This is because manifests are made up of layers, and a layer which holds a package database may not hold distribution information such as an os-release file.
A package scanner need only parse a target package database and return claircore.Packages.</p>
<p>You need to implement the <a href="../reference/packagescanner.html">Package Scanner</a> interface to achieve this.</p>
<p>Optionally, you may implement the <a href="../reference/configurable_scanner.html">Configurable Scanner</a> if the scanner needs to perform runtime configuration before use.</p>
<p>Keep in mind that its very common for distributions to utilize an existing package manager such as RPM.</p>
<p>If this is the case there's a high likelihood that you can utilize the existing "rpm" or "dpkg" package scanner implementations.</p>
<h2 id="implementing-a-distribution-scanner"><a class="header" href="#implementing-a-distribution-scanner">Implementing a Distribution Scanner</a></h2>
<p>Once the package scanner is implemented, tested, and working you can begin implementing a Distribution Scanner.</p>
<p>Implementing a distribution scanner is a design choice.
Distributions and repositories are the way claircore matches packages to vulnerabilities.</p>
<p>If your implemented Updater parses vulnerabilities with distribution information you will likely need to implement a distribution scanner.
Likewise, if your Updater parses vulnerabilities with repository information (typical with language vulnerabilities) you will likely need to implement a repository scanner.</p>
<p>A distribution scanner, like a package scanner, is provided a claircore.Layer.</p>
<p>The distribution scanner will parse the provided tar archive exhaustively searching for any clue that this layer was derived from your distribution.
If you identify that it is, you should return a common distribution used by your Updater implementation.
This ensures that claircore can match the output of your distribution scanner with your parsed vulnerabilities.</p>
<p>Optionally, you may implement the <a href="../reference/configurable_scanner.html">Configurable Scanner</a> if the scanner needs to perform runtime configuration before use.</p>
<h2 id="implementing-a-repository-scanner"><a class="header" href="#implementing-a-repository-scanner">Implementing a Repository Scanner</a></h2>
<p>As mentioned above, implementing a repository scanner is a design choice, often times applicable for language package managers.</p>
<p>If your Updater parses vulnerabilities with a repository field you will likely want to implement a repository scanner.</p>
<p>A repository scanner is used just like a distribution scanner however you will search for any clues that a layer contains your repository and if so return a common data model identifying the repository.</p>
<p>Optionally, you may implement the <a href="../reference/configurable_scanner.html">Configurable Scanner</a> if the scanner needs to perform runtime configuration before use.</p>
<h2 id="implementing-a-coalescer"><a class="header" href="#implementing-a-coalescer">Implementing a Coalescer</a></h2>
<p>As you may have noticed, the process of scanning a layer for packages, distribution, and repository information is distinct and separate.</p>
<p>At some point, claircore will need to take all the context-free information returned from layer scanners and create a complete view of the manifest.
A coalescer performs this computation.</p>
<p>It's unlikely you will need to implement your own coalescer.
Claircore provides a default "linux" coalescer which will work if your package database is rewritten when modified.
For example, if a Dockerfile's <code>RUN</code> command causes a change to to dpkg's <code>/var/lib/dpkg/status</code> database, the resulting manifest will have a copy placed in the associated layer.</p>
<p>However, if your package database does not fit into this model, implementing a coalescer may be necessary.</p>
<p>To implement a coalescer, several details must be understood:</p>
<ul>
<li>Each layer only provides a "piece" of the final manifest.
<ul>
<li>Because manifests are comprised of multiple copy-on-write layers, some layers may contain package information, distribution information, repository information, any combination of those, or no information at all.</li>
</ul>
</li>
<li>An OS may have a "dist-upgrade" performed and the implications of this on the package management system is distribution or language dependent.
<ul>
<li>The coalescer must deal with distribution upgrades in a sane way.
If your distribution or language does a dist-upgrade, are all packages bumped?
Are they simply left alone?
The coalescer must understand what happens and compute the final manifest's content correctly.</li>
</ul>
</li>
<li>Packages may be removed and added between layers.
<ul>
<li>When the package database is a regular file on disk, this case is simpler: the database file found in the most recent layer holds the ultimate set of packages for all previous layers.
However, in the case where the package database is realized by adding and removing files on disk it becomes trickier.
Claircore has no special handling of whiteout files, currently.
We will address this in upcoming releases.</li>
</ul>
</li>
</ul>
<p>If your distribution or language cannot utilize a default coalescer, you will need to implement the <a href="../reference/coalescer.html">Coalescer interface</a></p>
<h2 id="implementing-or-adding-to-an-ecosystem"><a class="header" href="#implementing-or-adding-to-an-ecosystem">Implementing or Adding To An Ecosystem</a></h2>
<p>An Ecosystem provides a set of coalescers, package scanners, distribution scanners, and repository scanners to Libindex at the time of indexing.</p>
<p>Libindex will take the <a href="../reference/ecosystem.html">Ecosystem</a> and scan each layer with all provided scanners.
When Libindex is ready to coalesce the results of each scanner into an <a href="../reference/index_report.html">IndexReport</a> the provided coalescer is given the output of the configured scanners.</p>
<p>This allows Libindex to segment the input to the coalescing step to particular scanners that a coalescer understands.</p>
<p>For instance, if we only wanted a (fictitious) Haskell coalescer to evaluate artifacts returned from a (fictitious) Haskell package and repository scanner we would create an ecosystem similar to:</p>
<pre><code class="language-go">// HaskellScanner returns a configured PackageScanner.
func haskellScanner() indexer.PackageScanner { return nil }

// HaskellCoalescer returns a configured Coalescer.
func haskellCoalescer() indexer.Coalescer { return nil }

// NewEcosystem provides the set of scanners and coalescers for the haskell
// ecosystem.
func NewEcosystem(ctx context.Context) *indexer.Ecosystem {
	return &amp;indexer.Ecosystem{
		PackageScanners: func(ctx context.Context) ([]indexer.PackageScanner, error) {
			return []indexer.PackageScanner{haskellScanner()}, nil
		},
		DistributionScanners: func(ctx context.Context) ([]indexer.DistributionScanner, error) {
			return []indexer.DistributionScanner{}, nil
		},
		RepositoryScanners: func(ctx context.Context) ([]indexer.RepositoryScanner, error) {
			return []indexer.RepositoryScanner{}, nil
		},
		Coalescer: func(ctx context.Context) (indexer.Coalescer, error) {
			return haskellCoalescer(), nil
		},
	}
}

</code></pre>
<p>This ensures that Libindex will only provide Haskell artifacts to the Haskell coalescer and avoid calling the coalescer with rpm packages for example.</p>
<p>If your distribution uses an already implemented package manager such as "rpm" or "dpkg", it's likely you will simply add your scanners to the existing ecosystem in one of those packages.</p>
<h2 id="alternative-implementations"><a class="header" href="#alternative-implementations">Alternative Implementations</a></h2>
<p>This how-to guide is a "perfect world" scenario.</p>
<p>Working on claircore has made us realize that this domain is a bit messy.
Security trackers are not developed with package managers in mind, security databases do not follow correct specs, distribution maintainers spin their own tools, etc.</p>
<p>We understand that supporting your distribution or language may take some bending of claircore's architecture and business logic.
If this is the case, start a conversation with us.
We are open to design discussions.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>At this point, you have implemented all the necessary components to integrate your distribution or language with claircore.</p>
<p>If you struggle with the design phase or are getting stuck at the implementation phases do not hesitate to reach out to us.
Here are some links:</p>
<ul>
<li><a href="https://groups.google.com/g/clair-dev?pli=1">Clair SIG</a></li>
<li><a href="https://github.com/quay/claircore">Github Issues</a></li>
<li><a href="https://issues.redhat.com/projects/PROJQUAY">RedHat Issues</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../howto.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../howto.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../docs/mermaid.min.js"></script>


    </div>
    </body>
</html>
