package main

import (
	"context"
	"errors"
	"flag"
	"fmt"
	"io"
	"log/slog"
	"os"
	"os/signal"
	"strconv"
	"text/template"
)

func main() {
	var code int
	var out io.Writer = os.Stdout
	defer func() {
		if c, ok := out.(io.Closer); ok {
			c.Close()
		}
		if code != 0 {
			os.Exit(code)
		}
	}()
	ctx, cancel := signal.NotifyContext(context.Background(),
		os.Interrupt)
	defer cancel()

	var opts Options
	var level slog.LevelVar
	flag.BoolFunc("D", "debug output", func(arg string) error {
		ok, _ := strconv.ParseBool(arg)
		if ok {
			level.Set(slog.LevelDebug)
		}
		return nil
	})
	flag.Func("o", "output file (default stdout)", func(arg string) error {
		f, err := os.Create(arg)
		if err != nil {
			return err
		}
		if out != os.Stdout {
			out.(*os.File).Close()
		}
		out = f
		return nil
	})
	flag.Parse()
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: &level,
	})))

	if err := Main(ctx, out, opts); err != nil {
		slog.ErrorContext(ctx, "failed", "reason", err)
	}
}

type Options struct{}

func Main(ctx context.Context, w io.Writer, opts Options) error {
	return errors.Join(
		writeC(ctx, w),
	)
}

func writeC(_ context.Context, w io.Writer) error {
	data := struct {
		Arena bool
		Decls []cDecl
	}{
		Decls: []cDecl{
			{Recv: "detector", Kind: cKindValid},
			{Recv: "detector", Kind: cKindString, Arg: "kind"},
			{Recv: "detector", Kind: cKindString, Arg: "name"},
			{Recv: "detector", Kind: cKindString, Arg: "version"},
			{Recv: "distribution", Kind: cKindValid},
			{Recv: "indexrecord", Kind: cKindRef, Arg: "package"},
			{Recv: "indexrecord", Kind: cKindRef, Arg: "distribution"},
			{Recv: "indexrecord", Kind: cKindRef, Arg: "repository"},
			{Recv: "package", Kind: cKindValid},
			{Recv: "range", Kind: cKindValid},
			{Recv: "repository", Kind: cKindValid},
			{Recv: "version", Kind: cKindValid},
			{Recv: "vulnerability", Kind: cKindRef, Arg: "package"},
			{Recv: "vulnerability", Kind: cKindRef, Arg: "distribution"},
			{Recv: "vulnerability", Kind: cKindRef, Arg: "repository"},
		},
	}
	t, err := template.New("C").Parse(cTmpls)
	if err != nil {
		return err
	}
	return t.Execute(w, data)
}

const cTmpls = `// Autogenerated, DO NOT EDIT.
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

// Types:
typedef __externref_t detector_ref;
typedef __externref_t distribution_ref;
typedef __externref_t indexrecord_ref;
typedef __externref_t package_ref;
typedef __externref_t range_ref;
typedef __externref_t repository_ref;
typedef __externref_t vulnerability_ref;
typedef uint32_t MatchConstraints;
typedef enum MatchConstraintFlags{
	PackageSourceName = 1<<0,
	PackageName = 1<<1,
	PackageModule = 1<<2,
	DistributionDID = 1<<3,
	DistributionName = 1<<4,
	DistributionVersion = 1<<5,
	DistributionVersionCodeName = 1<<6,
	DistributionVersionID = 1<<7,
	DistributionArch = 1<<8,
	DistributionCPE = 1<<9,
	DistributionPrettyName = 1<<10,
	RepositoryName = 1<<11,
	RepositoryKey = 1<<12,
	HasFixedInVersion = 1<<13,
} MatchConstraintFlags;
{{if .Arena}}
// Arena allocator.
//
// Thanks for the inspiration, skeeto:
// - https://nullprogram.com/blog/2023/09/27/
// - https://nullprogram.com/blog/2025/04/19/

// Some magic builtins and compiler wrangling:
size_t __builtin_wasm_memory_size(int);
size_t __builtin_wasm_memory_grow(int, size_t);
extern char __heap_base[];

typedef struct {
    char *beg;
    char *end;
} Arena;

static Arena getarena(void)
{
//	if(!init){
//		// Allocate our heap.
//		__builtin_wasm_memory_grow(0, __builtin_wasm_memory_size(0));
//		init = true;
//	}
    Arena a = {0};
    a.beg = __heap_base;
    a.end = (char *)(__builtin_wasm_memory_size(0) << 16);
    return a;
}

static void *alloc(Arena *a, ptrdiff_t count, ptrdiff_t size, ptrdiff_t align)
{
    ptrdiff_t pad = (ptrdiff_t)-(size_t)a->beg & (align - 1);
    char *r = a->beg + pad;
    a->beg += pad + count*size;
    return __builtin_memset(r, 0, (size_t)(size*count));
}

typedef struct {
    char *s;
	size_t len;
    ptrdiff_t cap;
} Str;

static Str allocStr(Arena *a, ptrdiff_t max)
{
	Str s = {0};
	char *p = alloc(a, 1, max, 4);
	s.s = p;
	s.cap = max;
	return s;
}
{{ end }}
// For use by the caller code:
#define EXPORT(s) __attribute__((export_name(s)))

// Host interface:
{{range .Decls -}}
{{.Signature}};
{{end -}}
`

type cDecl struct {
	Recv string
	Arg  string
	Kind cDeclKind
}

func (d *cDecl) Signature() (string, error) {
	var out string
	switch d.Kind {
	case cKindRef:
		const format = `__attribute((import_module("claircore_matcher_1"), import_name("%[1]s_get_%[2]s"))) %[2]s_ref %[1]s_get_%[2]s(%[1]s_ref)`
		out = fmt.Sprintf(format, d.Recv, d.Arg)
	case cKindString:
		const format = `__attribute((import_module("claircore_matcher_1"), import_name("%[1]s_get_%[2]s"))) ptrdiff_t %[1]s_get_%[2]s(%[1]s_ref, char*, size_t)`
		out = fmt.Sprintf(format, d.Recv, d.Arg)
	case cKindValid:
		const format = `__attribute((import_module("claircore_matcher_1"), import_name("%[1]s_valid"))) bool %[1]s_valid(%[1]s_ref)`
		out = fmt.Sprintf(format, d.Recv)
	default:
		return "", errors.New("unknown cDecl kind")
	}
	return out, nil
}

type cDeclKind int

const (
	_ cDeclKind = iota
	cKindRef
	cKindString
	cKindValid
)
