// Querymetadata is a tool to generate query metadata for PostgreSQL queries.
package main

import (
	"flag"
	"io/fs"
	"log"
	"os"
	"path"
	"reflect"
	"sort"
	"text/template"

	pg_query "github.com/pganalyze/pg_query_go/v4"
)

func main() {
	rootdir := flag.String("root", "queries", "root of query files")
	outfile := flag.String("out", "query_metadata.go", "output file")
	pkgname := flag.String("pkg", "postgres", "output package name")
	flag.Parse()

	var todos []todo
	root := os.DirFS(*rootdir)
	err := fs.WalkDir(root, ".", func(p string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if path.Ext(d.Name()) == ".sql" {
			f, err := fs.ReadFile(root, p)
			if err != nil {
				return err
			}
			todos = append(todos, todo{
				Path: p,
				Body: f,
			})
		}
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}

	m := meta{
		Package: *pkgname,
		Names:   []string{},
		Op:      make(map[string]string),
		Table:   make(map[string]string),
	}
	for _, t := range todos {
		m.Names = append(m.Names, t.Path)
		result, err := pg_query.Parse(string(t.Body))
		if err != nil {
			log.Fatalf("parsing %q: %v", t.Path, err)
		}
		ts, err := getTables(result)
		if err != nil {
			log.Fatalf("walking %q: %v", t.Path, err)
		}
		m.Table[t.Path] = ts[0].Ident
		stmt := result.Stmts[0]
		switch stmt.Stmt.Node.(type) {
		case *pg_query.Node_SelectStmt:
			m.Op[t.Path] = `SELECT`
		case *pg_query.Node_DeleteStmt:
			m.Op[t.Path] = `DELETE`
		case *pg_query.Node_InsertStmt:
			m.Op[t.Path] = `INSERT`
		case *pg_query.Node_UpdateStmt:
			m.Op[t.Path] = `UPDATE`
		case *pg_query.Node_RefreshMatViewStmt:
			m.Op[t.Path] = `REFRESH MATERIALIZED VIEW`
		default:
			log.Printf("handling %q: unimplemented: %+v", t.Path, stmt.Stmt.Node)
		}
	}
	f, err := os.Create(*outfile)
	if err != nil {
		log.Fatalf("create %q: %v", *outfile, err)
	}
	defer f.Close()
	if err := tmpl.Execute(f, &m); err != nil {
		log.Fatal(err)
	}
}

// GetTables returns the referenced tables in the query.
//
// The result is sorted such that names appear in order at every parse depth.
func getTables(res *pg_query.ParseResult) ([]foundTable, error) {
	var out []foundTable
	for _, raw := range res.Stmts {
		if err := walkNode(&out, raw.Stmt, 0); err != nil {
			return nil, err
		}
	}
	sort.SliceStable(out, func(i, j int) bool {
		return out[i].Depth < out[j].Depth
	})
	return out, nil
}

func walkNode(out *[]foundTable, x any, d int) error {
	if x == nil {
		return nil
	}
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)

	if t == reflect.TypeOf(pg_query.RangeVar{}) {
		*out = append(*out, foundTable{
			Ident: v.FieldByName("Relname").String(),
			Depth: d,
		})
		return nil
	}

	switch t.Kind() {
	case reflect.Pointer:
		if v.IsNil() {
			break
		}
		if err := walkNode(out, v.Elem().Interface(), d); err != nil {
			return err
		}
	case reflect.Slice:
		for i := 0; i < v.Len(); i++ {
			if err := walkNode(out, v.Index(i).Interface(), d+1); err != nil {
				return err
			}
		}
	case reflect.Struct:
		for i := 0; i < t.NumField(); i++ {
			if !t.Field(i).IsExported() {
				continue
			}
			if err := walkNode(out, v.Field(i).Interface(), d+1); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

type foundTable struct {
	Ident string
	Depth int
}

type todo struct {
	Path string
	Body []byte
}

type meta struct {
	Package string
	Names   []string
	Op      map[string]string
	Table   map[string]string
}

var tmpl = template.Must(template.New("root").Parse(`// Code generated by internal/cmd/querymetadata. DO NOT EDIT.

package {{.Package}}

var queryMetadata = struct {
	Table map[string]string
	Op    map[string]string
}{
	Table: map[string]string{
	{{range .Names}}	{{printf "%q" .}}: {{printf "%q" (index $.Table .)}},
	{{end}}},
	Op: map[string]string{
	{{range .Names}}	{{printf "%q" .}}: {{printf "%q" (index $.Op .)}},
	{{end}}},
}
`))
