package postgres

import (
	"hash/maphash"
	"strconv"
	"sync"

	"github.com/jackc/pgtype/zeronull"
	"github.com/jackc/pgx/v5"
	"github.com/quay/claircore"
)

// VulnArena is a helper to construct the return for [MatcherV1.Get].
//
// Users should call [CurrentID] with the "current" ID, then Scan into the
// [*vulnArena]. Scan will de-duplicate the various objects across multiple
// calls.
type vulnArena struct {
	curID string
	ret   map[string][]*claircore.Vulnerability
	// Local key to index.
	pkgLookup  map[uint64]int
	distLookup map[uint64]int
	repoLookup map[uint64]int
	// ID to index.
	vulnLookup map[int64]int
	// Actual structs.
	pkg  []claircore.Package
	dist []claircore.Distribution
	repo []claircore.Repository
	vuln []claircore.Vulnerability
}

func newVulnArena() *vulnArena {
	a := vulnArena{
		ret:        make(map[string][]*claircore.Vulnerability),
		pkgLookup:  make(map[uint64]int),
		distLookup: make(map[uint64]int),
		repoLookup: make(map[uint64]int),
		vulnLookup: make(map[int64]int),
	}
	return &a
}

func (a *vulnArena) CurrentID(id string) {
	a.curID = id
}

func (a *vulnArena) Result() map[string][]*claircore.Vulnerability {
	return a.ret
}

// - 0  id
// - 1  name
// - 2  description
// - 3  issued
// - 4  links
// - 5  severity
// - 6  normalized_severity
// - 7  package_name
// - 8  package_version
// - 9  package_module
// - 10 package_arch
// - 11 package_kind
// - 12 dist_id
// - 13 dist_name
// - 14 dist_version
// - 15 dist_version_code_name
// - 16 dist_version_id
// - 17 dist_arch
// - 18 dist_cpe
// - 19 dist_pretty_name
// - 20 arch_operation
// - 21 repo_name
// - 22 repo_key
// - 23 repo_uri
// - 24 fixed_in_version
// - 25 updater
// - 26 vulnerable_range
// - 27 version_kind
func (a *vulnArena) ScanRow(rows pgx.Rows) error {
	var id int64
	err := rows.Scan(&id, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil)
	if err != nil {
		return err
	}
	if idx, ok := a.vulnLookup[id]; ok {
		a.ret[a.curID] = append(a.ret[a.curID], &a.vuln[idx])
		return nil
	}

	vi := len(a.vuln)
	a.vuln = append(a.vuln, claircore.Vulnerability{
		Range: new(claircore.Range),
	})
	a.vulnLookup[id] = vi
	v := &a.vuln[vi]
	a.ret[a.curID] = append(a.ret[a.curID], v)
	v.ID = strconv.FormatInt(id, 10)
	var verKind *string
	desc := zeronull.Text(v.Description)
	issued := zeronull.Timestamptz(v.Issued)
	links := zeronull.Text(v.Links)
	sev := zeronull.Text(v.Severity)
	fixed := zeronull.Text(v.FixedInVersion)
	err = rows.Scan(nil, &v.Name, &desc, &issued, &links, &sev, &v.NormalizedSeverity, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, &fixed, &v.Updater, &v.Range, &verKind)
	if err != nil {
		return err
	}
	if verKind != nil {
		v.Range.Lower.Kind = *verKind
		v.Range.Upper.Kind = *verKind
	}

	var pkg claircore.Package
	var dist claircore.Distribution
	var repo claircore.Repository
	mod := zeronull.Text(pkg.Module)
	rname := zeronull.Text(repo.Name)
	rkey := zeronull.Text(repo.Key)
	ruri := zeronull.Text(repo.URI)
	did := zeronull.Text(dist.DID)
	dname := zeronull.Text(dist.Name)
	dver := zeronull.Text(dist.Version)
	dvcn := zeronull.Text(dist.VersionCodeName)
	dvid := zeronull.Text(dist.VersionID)
	darch := zeronull.Text(dist.Arch)
	dpn := zeronull.Text(dist.PrettyName)
	dcpe := &dist.CPE // Note the double-pointer.
	err = rows.Scan(nil, nil, nil, nil, nil, nil, nil,
		&pkg.Name, &pkg.Version, &mod, &pkg.Arch, &pkg.Kind,
		&did, &dname, &dver, &dvcn, &dvid, &darch, &dcpe, &dpn,
		&rname, &rkey, &ruri,
		nil, nil, nil, nil, nil)
	if err != nil {
		return err
	}

	v.Package = a.lookupPackage(pkg)
	v.Dist = a.lookupDistribution(dist)
	v.Repo = a.lookupRepository(repo)

	return nil
}

// NOTE(hank) I couldn't figure out a way to write these methods as a generic
// function, because `func[T any](a *vulnArena, v T) *T` doesn't work the way I
// think it should.

func (a *vulnArena) lookupPackage(v claircore.Package) *claircore.Package {
	h := getHasher()
	defer putHasher(h)
	h.WriteString(v.Name)
	h.WriteString(v.Version)
	h.WriteString(v.Kind)
	h.WriteString(v.PackageDB)
	h.WriteString(v.Filepath)
	h.WriteString(v.RepositoryHint)
	h.WriteString(v.NormalizedVersion.String())
	h.WriteString(v.Module)
	h.WriteString(v.Arch)
	h.WriteString(v.CPE.BindFS())
	id := h.Sum64()
	i, ok := a.pkgLookup[id]
	if !ok {
		i = len(a.pkg)
		a.pkgLookup[id] = i
		a.pkg = append(a.pkg, v)
	}
	return &a.pkg[i]
}

func (a *vulnArena) lookupDistribution(v claircore.Distribution) *claircore.Distribution {
	h := getHasher()
	defer putHasher(h)
	h.WriteString(v.DID)
	h.WriteString(v.Name)
	h.WriteString(v.Version)
	h.WriteString(v.VersionCodeName)
	h.WriteString(v.VersionID)
	h.WriteString(v.Arch)
	h.WriteString(v.CPE.BindFS())
	h.WriteString(v.PrettyName)
	id := h.Sum64()
	i, ok := a.distLookup[id]
	if !ok {
		i = len(a.dist)
		a.distLookup[id] = i
		a.dist = append(a.dist, v)
	}
	return &a.dist[i]
}

func (a *vulnArena) lookupRepository(v claircore.Repository) *claircore.Repository {
	h := getHasher()
	defer putHasher(h)
	h.WriteString(v.Name)
	h.WriteString(v.Key)
	h.WriteString(v.URI)
	h.WriteString(v.CPE.BindFS())
	id := h.Sum64()
	i, ok := a.repoLookup[id]
	if !ok {
		i = len(a.repo)
		a.repoLookup[id] = i
		a.repo = append(a.repo, v)
	}
	return &a.repo[i]
}

var (
	hasherPool sync.Pool
	hasherSeed = maphash.MakeSeed()
)

func getHasher() *maphash.Hash {
	h, ok := hasherPool.Get().(*maphash.Hash)
	if !ok {
		h = &maphash.Hash{}
		h.SetSeed(hasherSeed)
	}
	h.Reset()
	return h
}
func putHasher(h *maphash.Hash) {
	hasherPool.Put(h)
}
